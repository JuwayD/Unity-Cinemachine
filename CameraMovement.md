
# 功能简介
该模块的工作内容为处理游戏中产生的数据，并生成平滑变化的运镜参数提交给cinemachine插件，负责将游戏数据按照需求转化成cinemachine使用的数据。
并在此基础之上提供相机运行状态切换，cinemachine本身调控的功能(虚拟相机混合，插件管理等)。
---
### 上下文:
其中处理游戏中产生数据的模块我们称之为上下文，上下文会对数据进行处理可能会产生一些用于维护自身状态的变量这部分称为数据区，
数据区用于存储上下文自身运行需要的变量并依据这些变量执行运算，逻辑判断和触发***时机***，这部分数据可以视需求暴露给配置使用读取和写入。
数据区处理后最终会产生用于控制cinemachine的数据，为了方便和cinemachine交互会存入一个数据区，这部分数据区归属于上下文，
，称为**cinemachine操控区**，
操控区会自己处理数据混合，打断的问题，并每帧将当前处理的结果数据对当前数据按照曲线和deltatime读取这一帧变化数据提交给cinemachine，
最终cinemacchine完成运镜操作。
> **数据区实现方式**:需要解决如何将配置转换成对应运算，逻辑判断，时机触发以及如何将数据和时机开放给配置
> - **如何将数据和时机开放给配置**:目前考虑OdinInspector使用这个插件，或者利用反射和attribute进行动态检测，好处是程序可以完全不需要去管理配置，改完数据结构后
> 配置的地方能利用反射通过检测字段完成自适应。数据结构分为全局变量和抽象变量或者全局变量+时机变量,定义好触发补正的时机，和时机对应的上下文及其携带的局部变量，
    这部分变量会进行一次抽象（_或者不抽，方案待定，抽可以减少上下文数量和其中的变量数量理论上上下文就只需要时机抽象上下文和全局上下文
    ，减少规模降低理解成本，不抽更直观，且部分变量并不好抽象_） 
> 
> - **抽象举例**:
> - 相机运行经常需要计算最终位置，这个可能依据某个变量进行放大缩小，这个变量对运镜而言就是要变化的 程度 因此凡是这种作用的变量，
    > 可以抽象成程度。
> - 相机运行经常需要使用方向，来决定该往上还是往下，往左还是往右，用于控制相机方向的变量可以抽象成 方向。
> **难以抽象的变量**:
> - 通常是用于判定的条件变量，比如当释放某个指定技能时执行一个运镜，这个指定技能就不好抽象。
> > ---
> - **如何解决变量计算和逻辑判断**:考虑内置逻辑表达式与运算表达式的字符串解析函数，编辑器中配置运算表达式和逻辑表达式，运行时解析，字符串因为是
> 静态定死的不会有额外GC，但需要考虑解析函数的实现能否避免产生GC如果产生能否缓存，解析函数会不会占用较大CPU时间。这些问题如果没法解决那么
> 这部分只能抽象成节点或者枚举，实现逻辑由程序完成。
> > ---
> **cinemachine操控区的实现方式**:需要解决数据混合和打断的问题，保证数据拥有可控的平滑控制，并且需要准确知道应该映射到cinemachine的哪个值
> - **数据混合举例**:进入战斗需要将zoom放大1倍直到退出，受击需要将zoom放大0.5倍持续0.5s，按下防御进入防御姿态，zoom需要固定为1.3
> - ，进入战斗后受击了此时zoom数据应该为多少，受击结束后又该是多少，边受击边防御该是多少(*方案待定*)
>
> - **解决方案1**:使用队列结构，队列中存储对该字段所有来源的输入，优先级，及其计算方式，每帧按优先级即添加顺序排序遍历所有元素并按照顺序和运算方式依次计算，打断就是清空队列
> 每帧检测所有生效模板遍历并将模板携带的字段信息其优先级存入对应的字段队列之中，然后按照混合算法计算出最终值。  
> 好处:可以对每个字段的优先级做精细控制  
> 坏处:开发成本较高，较难维护，运行时开销增加
> - **解决方案2**:依然使用队列，但是队列中存储的是模板，原本字段的信息统一挪到单个模板上  
> 好处:更容易维护，更容易配置，开发成本降低，运行时开销降低  
> 坏处:无法对每个字段精细控制
> > ---
> 
> - **映射问题举例**:配置一个值希望用于控制zoom，如何真正在运行时找到对应的cinemachine字段，最好是自动适应扩展，兼容各种插件，组件，
> 比如新开发了一个cinemachine拓展，配置和运行时都能自动探测并生成映射关系(*方案待定*)
> - **解决方案1**:考虑使用反射自动检测所有cinemachine组件和扩展（只检测public字段），自动生成对应配置模板，和映射脚本（为每个字段生成id或枚举，以及对应的
> switch\-case代码。这样才操控区确定最终数据后，传给映射脚本即可自动完成对cinemachine的赋值。  
> 好处:全自动运行消耗低（switch-case O（1）消耗）自动生成脚本可以扩展到任意配置处  
> 坏处:自动脚本生成会产生开发成本
> - **解决方案2**:全部使用字符串和反射，使用反射生成配置模板，运行时使用反射和字符串比对找到对应字段并赋值。  
> 好处:全自动，省心，开发成本低  
> 坏处:运行时消耗较高（并不会产生额外GC，字符串皆是静态,后续比对也是读取值）。
>
> > ---
>
> - **操控区数据来源**:上下文监控外部数据，并利用数据区辅助，判定是否需要使用运镜，使用哪个模板，通过模板id读取配置，配置中携带计算方式，及来源，优先级，变化时间，变化曲线其中变化曲线如果没有相应配置则沿用当前的曲线
>
> >---
>
> - **变化控制**: 从当前到目标值的过程配置化并提供默认曲线,也可以直接强设，强设在规则和一些tick性事件中很有效
> - **解决问题**:方便美术或者策划调整变化过程运镜效果，提供默认值降低配置成本
---
### 编辑器操作及配置文件格式:
由于cinemachine的参数繁杂量多，几乎很少出现运行时完全通过数据产生一整套运镜参数的情况，大部分时候需要的是一份拥有大量运镜参数的模板，
在程序运行到某个时机时按照模板来运镜:
> 示例:
> - 如进行对话时固定运镜到主角斜后方
> - 防守时固定拉到主角身后
> - 玩家主动重置镜头时恢复一个默认视角（通常是背后，偏主角一点的位置）

这些模板数据通常大部分是静态的，这些静态数据应该尽量和外部模块剥离，减少耦合，配置化就是个很好办法，一个模板可能拥有数十个数据，
但是外部只需要一个id就可以调用，因此首先模板可以配置化，让策划按照需求自己进行模板的配置。 
有时候会存在需要依据游戏数据对其中的一两个参数进行调整的情况，这种通过变量实现。
> - **数据配置方案**:规则和补正似乎可以统一？规则本质是一直都在触发的补正（可以定义没有触发时机的补正就在当前状态一直触发）？  
> **基本结构**:CameraProduce:时机-条件表达式（这部分会执行逻辑表达式解析）-模板id  
> **模板结构**:可以分为三部分，分别是描述模板本身的字段和用于控制cinemachine的字段以及配置可以写入的变量，
> 依据映射方式和操控区实现方式模板描述和cinemachine控制字段有这两部分分别对应两种格式，
> 但都是key-value的列表（不采用全字段，减少内存消耗）。
> - **映射方式为使用映射脚本时**:asset内key为枚举或者id。
> - **映射方式为使用全反射时**:asset内key为cinemachine中公开字段的名称（字符串形式）。
> - **操控区实现方式为模板式时**:value就是目标值，模板描述部分则需要设置持续时间，变化曲线，优先级。
> - **操控区实现方式为字段式时**:则模板描述部分内容会被塞进value中。
> - 其中一些字段可以填写表达式用于执行运算表达式，如目标值，持续时间，优先级，可写入变量部分  
> 表达式部分填写字符串
（*最终哪些可以待定，也可以通过attribute和反射方式动态确定，否则则在代码中写死哪些字段需要执行运算表达式解析*）
> - 编辑器中操作采用全字段展示（类似于直接配置cinemachine插件，不也采用key-value列表形式是为了降低配置上的操作成本）
---
### 状态机:
游戏中经常会出现相机的整套运行逻辑发生变化的情况:
> 示例:
> - 如原本是第三人称需要切换成第一人称
> - 如原本是俯视角需要切换成第三人称
> - 原本是固定视角相机要切换成肩抗视角

这些情况下相机操控逻辑几乎和之前完全不同，此时对应到cinemachine通常是使用的虚拟相机类型发生变化或挂载的组件发生变化，
如果直接删除添加组件会导致相机畸变，因此这里应该是使用另一个虚拟相机并使用cinemachine的blend。  
由于控制方式被替换，因此原本执行的模板都会失效，因此需要保证原本的模板当帧的执行要执行完成（最后一帧可能执行一些还原操作），
并执行清理（如果使用方案1可能需要保留用于还原相机数据）。
每个状态对应一个cinemachine组件及扩展的组合，切换状态时如果是方案1，直接动态加载组合的组件和扩展。
如果是方案2或者方案3则需要建立组合和相机的扩展并进行切换。模板会和某个扩展或者组件绑定，如果通过条件的模板与扩展类型不一致将不会生效
> **如何产生下一个虚拟相机**:
> **解决方案1**：使用相机池和动态加载的办法，虚拟相机只是个组件加载应该不会造成卡顿，***优先考虑***  
> 好处:理论上只需要两个虚拟相机两个过渡，因为当前运行的只有一个虚拟相机，新切换发生时用上一个动态挂载组件即可。  
> 坏处:是可能影响性能，并且对于需要一直跟随玩家这种长期存在的相机，可能需要额外处理数据还原问题。
> **解决方案2**:事先就将游戏中需要的相机准备好作为一个预制件直接挂载在场景里或预加载。  
> 好处:是性能好，没有动态挂载组件的开销，相机本就一直存在不需要考虑数据还原问题。  
> 坏处:是可能会拥有大量虚拟相机。  
> **解决方案3**:将相机存入栈结构，配合相机池，每次使用一个新相机就会入栈要切回去时就出栈，这里需要考虑如何甄别相机是否已经入栈，
> 出栈时如何找到要出到第几个的问题，脑袋要炸了 先不想。  
> 好处:解决还原问题，一般情况下虚拟相机数量可控。  
> 坏处:脑袋疼 开发，维护成本变高，性能开销略大。
---
### 工作流:
**需求举例**:当处于玩家处于移动状态时相机转角依据玩家垂直于摄像机方向上的位移发生变化，运算方式为叠加
首先策划需要配置一个运镜模板，模板中控制cinemachine中freelook.X_Value.Value字段部分需要设置一个表达式，
表达式需要使用到上下文提供的变量 *玩家垂直于摄像机方向上的位移* * 固定系数 计算方式为+ 持续时间为0也就是一帧瞬切
模板只配置转角这一个参数，因为其他的不会进行控制。
其次由于只有玩家处于移动状态才执行因此需要配置条件表达式，使用上下文提供的变量 *玩家状态* == int值
由于这个不是特定时机触发因此触发时机应该为Tick每帧触发
运行时：将会每帧判断条件，如果跳过则将表达式传入解析函数，解析函数会将表达式顺序执行的表达式（好像叫逆波兰表达式）其中变量部分传入映射函数
（如果使用映射方式的话)获取运行时的值，最终顺序循环求值，将值存入队列。
如果有其他模板 也会执行相同的操作，最终得到最终的模板队列 或 一个个属性队列，利用混合算法后得到最终值，并付给cinemachine插件。
